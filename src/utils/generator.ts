import { saveAs } from 'file-saver';
import { Node, Edge } from '@xyflow/react';
import { ProjectSettings, ActionItem, ConditionItem } from '../types';

// Helper to convert visual actions to JS code
const compileActions = (actions?: ActionItem[]): string => {
    if (!actions || actions.length === 0) return '';
    
    return actions.map((a) => {
        // Helper to generate value expression (supports dice)
        const getValueExpr = (v: any) => {
            if (typeof v === 'number') return v;
            const str = String(v).trim();
            if (!str) return 0;
            if (/^-?\d+(\.\d+)?$/.test(str)) return Number(str);
            return `rollDice(${JSON.stringify(str)})`;
        };

        if (a.type === 'item') {
            const itemName = JSON.stringify(a.target ?? '');
            const quantity = getValueExpr(a.value || 1);
            
            if (a.operation === '+' || a.operation === '+=') {
                return `state.inventory = state.inventory || {}; 
                        if(Array.isArray(state.inventory)) state.inventory = {};
                        state.inventory[${itemName}] = (state.inventory[${itemName}] || 0) + ${quantity};`;
            } else {
                return `state.inventory = state.inventory || {};
                        if(Array.isArray(state.inventory)) state.inventory = {};
                        state.inventory[${itemName}] = Math.max(0, (state.inventory[${itemName}] || 0) - ${quantity});
                        if(state.inventory[${itemName}] <= 0) delete state.inventory[${itemName}];`;
            }
        } else {
            // Stat modification
            let code = `state.stats = state.stats || {};`;
            const val = getValueExpr(a.value || 0);
            const k = JSON.stringify(a.target ?? '');
            
            if (a.operation === '=') {
                code += `state.stats[${k}] = ${val};`;
            } else if (a.operation === '+' || a.operation === '+=') {
                code += `state.stats[${k}] = (state.stats[${k}] || 0) + ${val};`;
            } else if (a.operation === '-' || a.operation === '-=') {
                code += `state.stats[${k}] = (state.stats[${k}] || 0) - ${val};`;
            }
            return code;
        }
    }).join('\n');
};

// Helper to convert visual conditions to JS code
const compileConditions = (conditions?: ConditionItem[], logic: string = 'AND'): string => {
    if (!conditions || conditions.length === 0) return 'true';
    
    const checks = conditions.map((c) => {
        if (c.type === 'has_item') {
            const itemName = JSON.stringify(c.target ?? '');
            const quantity = typeof c.value === 'number' ? c.value : parseInt(c.value as string) || 1;
            // Support both old array format and new object format
            return `((Array.isArray(state.inventory) ? state.inventory.includes(${itemName}) : (state.inventory && state.inventory[${itemName}] >= ${quantity})))`;
        } else {
            // Stat check
            const raw = c.value ?? 0;
            const num = typeof raw === 'number' ? raw : Number(raw);
            const val = Number.isFinite(num) ? num : JSON.stringify(String(raw));
            const statKey = JSON.stringify(c.target ?? '');
            const statRef = `(state.stats && state.stats[${statKey}] || 0)`;
            
            switch(c.operation) {
                case '>': return `${statRef} > ${val}`;
                case '<': return `${statRef} < ${val}`;
                case '>=': return `${statRef} >= ${val}`;
                case '<=': return `${statRef} <= ${val}`;
                case '=': case '==': return `${statRef} == ${val}`;
                default: return 'true';
            }
        }
    });

    if (logic === 'OR') {
        return `(${checks.join(' || ')})`;
    }
    return `(${checks.join(' && ')})`;
};

const HEADER_TEMPLATE = `// ==UserScript==
// @name         __PLUGIN_NAME__
// @author       __AUTHOR__
// @version      __VERSION__
// @description  __DESCRIPTION__
// @timestamp    __TIMESTAMP__
// @license      MIT
// @homepageURL  __HOMEPAGE__
// ==/UserScript==
`;

const PLUGIN_TEMPLATE_START = `// Plot Novel Sealdice Plugin Editor Generated Plugin
// Auto-generated by 剧情小说海豹插件编辑器

function main() {
  // 扩展注册
  let ext = seal.ext.find('__PLUGIN_NAME__');
  if (!ext) {
    ext = seal.ext.new('__PLUGIN_NAME__', '__AUTHOR__', '__VERSION__');
    seal.ext.register(ext);
  }

  // 故事数据
  const STORY_DATA = __STORY_DATA_PLACEHOLDER__;
  const CMD_NAME = '__COMMAND_NAME__';
  
  // 自定义的命令取出来
  const SC_START = '__SC_START__';
  const SC_NEXT = '__SC_NEXT__';
  const SC_CHOOSE = '__SC_CHOOSE__';
  const SC_STAT = '__SC_STAT__';
  const SC_LOAD = '__SC_LOAD__';
  const SC_RESET = '__SC_RESET__';
  const SC_CLEAR = '__SC_CLEAR__';

  const CRITICAL_SUCCESS = __CRITICAL_SUCCESS__;
  const CRITICAL_FAILURE = __CRITICAL_FAILURE__;
  const SUCCESS_MODE = '__SUCCESS_MODE__';
  const CRITICAL_SUCCESS_MODE = '__CRITICAL_SUCCESS_MODE__';
  const CRITICAL_FAILURE_MODE = '__CRITICAL_FAILURE_MODE__';
  const DEFAULT_DICE = '__DEFAULT_DICE__';

  function replyToSender (ctx, msg, text) {
    const raw = text == null ? '' : String(text);
    const parts = raw.split('\\f');

    if (parts.length <= 1) {
      return seal.replyToSender(ctx, msg, raw);
    }

    let idx = 0;
    for (const part of parts) {
      if (!part || part.trim() === '') continue;
      const delay = idx * 200; // 整0.2秒延迟，应该不会乱序吧？乱序就调大一点
      idx += 1;
      if (delay === 0) seal.replyToSender(ctx, msg, part);
      else setTimeout(() => seal.replyToSender(ctx, msg, part), delay);
    }
  };

  // 掷骰表达式解析
  const rollDice = (expr) => {
      if (typeof expr === 'number') return expr;
      let str = String(expr).toLowerCase().replace(/\\s/g, '');
      try {
          str = str.replace(/(\\d*)d(\\d+)/g, (match, count, sides) => {
              let n = count === '' ? 1 : parseInt(count);
              let s = parseInt(sides);
              let total = 0;
              for(let i=0; i<n; i++) total += Math.floor(Math.random() * s) + 1;
              return total;
          });
          return new Function('return ' + str)();
      } catch(e) { return 0; }
  };

  // 数据管理
  const loadState = (userId) => {
    try {
      const data = ext.storageGet(\`user_\${userId}\`);
      return data ? JSON.parse(data) : null;
    } catch (e) { return null; }
  };

  const saveState = (userId, state) => {
    ext.storageSet(\`user_\${userId}\`, JSON.stringify(state));
  };

  const resetState = (userId) => {
    const initialState = {
      currentNodeId: STORY_DATA.startNodeId,
      stats: {},
      inventory: {},
      history: [],
      savePoints: {}
    };
    saveState(userId, initialState);
    return initialState;
  };

  // 命令相关处理
  const cmd = seal.ext.newCmdItemInfo();
  cmd.name = CMD_NAME;
  cmd.help = \`__COMMAND_HELP__\`;
  
  cmd.solve = (ctx, msg, cmdArgs) => {
    const userId = ctx.player.userId;
    let state = loadState(userId);
    const subCmd = cmdArgs.getArgN(1);

    if (subCmd === SC_CLEAR || subCmd === 'clr') {
        ext.storageSet(\`user_\${userId}\`, '');
        replyToSender(ctx, msg, '个人数据已清除。');
        return seal.ext.newCmdExecuteResult(true);
    }

    if (subCmd === SC_START) {
      state = resetState(userId);
      processNode(ctx, msg, state);
      return seal.ext.newCmdExecuteResult(true);
    }

    if (!state) {
      state = resetState(userId);
    }

    if (subCmd === SC_RESET) {
        state = resetState(userId);
        replyToSender(ctx, msg, '故事已重置。');
        return seal.ext.newCmdExecuteResult(true);
    } else if (subCmd === SC_STAT) {
        const stats = state.stats || {};
        const inv = state.inventory || {};
        let output = '个人属性:\\n';
        
        const hasStats = Object.keys(stats).length > 0;
        const hasInv = Array.isArray(inv) ? inv.length > 0 : Object.keys(inv).length > 0;

        if (!hasStats && !hasInv) {
            output += '无';
        } else {
            for (let k in stats) output += \`\${k}: \${stats[k]}\\n\`;
            if (hasInv) {
                if (Array.isArray(inv)) {
                     output += \`物品: \${inv.join(', ')}\`;
                } else {
                     const items = [];
                     for(let k in inv) items.push(\`\${k} x\${inv[k]}\`);
                     output += \`物品: \${items.join(', ')}\`;
                }
            }
        }
        replyToSender(ctx, msg, output);
        return seal.ext.newCmdExecuteResult(true);
    } else if (subCmd === SC_LOAD) {
        let pointId = cmdArgs.getArgN(2);
        
        if (!pointId) {
             const savePoints = state.savePoints || {};
             const keys = Object.keys(savePoints);
             if (keys.length === 0) {
                 replyToSender(ctx, msg, '当前没有可用存档点。');
             } else {
                 let output = '可用存档点:\\n';
                 keys.forEach(k => {
                     output += \`- \${k}\\n\`;
                 });
                 output += \`\\n使用 .\${CMD_NAME} \${SC_LOAD} <id> 读取\`;
                 replyToSender(ctx, msg, output);
             }
             return seal.ext.newCmdExecuteResult(true);
        }

        if (state.savePoints && state.savePoints[pointId]) {
             const saved = state.savePoints[pointId];
             const currentSavePoints = state.savePoints;
             
             state = JSON.parse(JSON.stringify(saved));
             
             state.savePoints = currentSavePoints;
             
             saveState(userId, state);
             replyToSender(ctx, msg, \`已加载存档点: \${pointId}\`);

             processNode(ctx, msg, state);
        } else {
             replyToSender(ctx, msg, \`未找到存档点: \${pointId}\`);
        }
        return seal.ext.newCmdExecuteResult(true);
    }

    if (!STORY_DATA.nodes[state.currentNodeId]) {
      replyToSender(ctx, msg, 'Error: 找不到当前节点信息，请尝试重置。');
      return seal.ext.newCmdExecuteResult(true);
    }

    // 选择节点处理
      if (subCmd === SC_CHOOSE) {
        if (state.isEnded) {
             replyToSender(ctx, msg, \`故事已结束。回复 .\${CMD_NAME} \${SC_START} 重新开始。\`);
             return seal.ext.newCmdExecuteResult(true);
        }
        const currentNode = STORY_DATA.nodes[state.currentNodeId];
      if (!currentNode.choices) {
        replyToSender(ctx, msg, \`当前无需选择，请使用 .\${CMD_NAME} \${SC_NEXT} 继续\\n(回复 .\${CMD_NAME} help 查看帮助)\`);
        return seal.ext.newCmdExecuteResult(true);
      }
        const choiceIdx = parseInt(cmdArgs.getArgN(2)) - 1;
        const choice = currentNode.choices[choiceIdx];
        if (!choice) {
          replyToSender(ctx, msg, '无效的选项。');
          return seal.ext.newCmdExecuteResult(true);
        }
        
        if (choice.script) {
            try {
                new Function('state', 'seal', 'ctx', 'rollDice', choice.script)(state, seal, ctx, rollDice);
            } catch (e) {
                console.error('Choice Script error:', e);
                replyToSender(ctx, msg, \`Choice Error: \${e.message}\`);
            }
        }

        state.currentNodeId = choice.next;
        saveState(userId, state);
        
        processNode(ctx, msg, state);
        return seal.ext.newCmdExecuteResult(true);
      }

    // 继续命令处理
    if (subCmd === SC_NEXT) {
        if (state.isEnded) {
             replyToSender(ctx, msg, \`故事已结束。回复 .\${CMD_NAME} \${SC_START} 重新开始。\`);
             return seal.ext.newCmdExecuteResult(true);
        }
        const currentNode = STORY_DATA.nodes[state.currentNodeId];
        
        if (currentNode.choices) {
             replyToSender(ctx, msg, \`请先做出选择: .\${CMD_NAME} \${SC_CHOOSE} <序号>\\n(回复 .\${CMD_NAME} help 查看帮助)\`);
             return seal.ext.newCmdExecuteResult(true);
        }
        
        if (currentNode.next) {
            state.currentNodeId = currentNode.next;
            saveState(userId, state);
            processNode(ctx, msg, state);
        } else {
            replyToSender(ctx, msg, currentNode.text + '\\n(故事结束)');
        }
        return seal.ext.newCmdExecuteResult(true);
    }
    
    replyToSender(ctx, msg, cmd.help);
    return seal.ext.newCmdExecuteResult(true);
  };

  function processNode(ctx, msg, state) {
    let nodeId = state.currentNodeId;
    let node = STORY_DATA.nodes[nodeId];
    if (!node) return;

    // 存档点处理
    if (node.savePointId) {
        state.savePoints = state.savePoints || {};
        const snapshot = JSON.parse(JSON.stringify(state));
        delete snapshot.savePoints; 
        state.savePoints[node.savePointId] = snapshot;
        saveState(ctx.player.userId, state);
    }

    if (node.script) {
        try {
            new Function('state', 'seal', 'ctx', 'rollDice', node.script)(state, seal, ctx, rollDice);
            saveState(ctx.player.userId, state); 
        } catch (e) {
            console.error('Script error:', e);
            replyToSender(ctx, msg, \`Script Error: \${e.message}\`);
        }
    }

    if (node.type === 'check') {
        const targetVal = parseInt(node.checkTarget) || (state.stats[node.checkTarget] || 50);
        const dice = node.checkDice || DEFAULT_DICE;
        
        let roll = rollDice(dice);

        let result = '';
        let nextId = null;

        const isSuccess = SUCCESS_MODE === 'gte' ? roll >= targetVal : roll <= targetVal;
        const isCriticalSuccess = CRITICAL_SUCCESS_MODE === 'gte' ? roll >= CRITICAL_SUCCESS : roll <= CRITICAL_SUCCESS;
        const isCriticalFailure = CRITICAL_FAILURE_MODE === 'gte' ? roll >= CRITICAL_FAILURE : roll <= CRITICAL_FAILURE;

        if (isCriticalSuccess && node.nextGreatSuccess) {
            result = \`大成功 (Ref: \${CRITICAL_SUCCESS})\`;
            nextId = node.nextGreatSuccess;
        } else if (isCriticalFailure && node.nextGreatFailure) {
            result = \`大失败 (Ref: \${CRITICAL_FAILURE})\`;
            nextId = node.nextGreatFailure;
        } else if (isSuccess) {
            result = '成功';
            nextId = node.nextSuccess || node.nextGreatSuccess; // Fallback
        } else {
            result = '失败';
            nextId = node.nextFailure || node.nextGreatFailure; // Fallback
        }
        
        if (!nextId) {
             if (isSuccess) nextId = node.nextSuccess;
             else nextId = node.nextFailure;
        }

        const output = \`检定 \${node.checkTarget} (\${targetVal})\\n结果: \${roll} / \${dice} -> \${result}\`;
        replyToSender(ctx, msg, output);

        if (nextId) {
            state.currentNodeId = nextId;
            saveState(ctx.player.userId, state);
            setTimeout(() => processNode(ctx, msg, state), 500); // Small delay for dramatic effect
        } else {
            replyToSender(ctx, msg, '(错误: 检定后无路可走)');
        }
        return;
    }

    if (node.type === 'condition') {
        let conditionResult = false;
        try {
             conditionResult = new Function('state', 'return ' + node.condition)(state);
        } catch (e) {
             console.error('Condition error:', e);
        }

        const nextId = conditionResult ? node.nextTrue : node.nextFalse;
        if (nextId) {
            state.currentNodeId = nextId;
            saveState(ctx.player.userId, state);
            processNode(ctx, msg, state);
            return;
        } else {
             replyToSender(ctx, msg, \`(逻辑判定结束: \${conditionResult ? 'True' : 'False'} - 无后续节点)\`);
             return;
        }
    }

    let output = node.text || '';
    
    // Add [Save Point] indicator if applicable
    if (node.savePointId) {
        output = \`[存档点: \${node.savePointId}]\\n\` + output;
    }

    if (node.choices) {
        output += '\\n\\n选项:';
        node.choices.forEach((c, i) => {
            output += \`\\n\${i + 1}. \${c.text}\`;
        });
        output += \`\\n(回复 .\${CMD_NAME} \${SC_CHOOSE} <序号>)\`;
    } else if (node.randomNext) {
        const r = Math.random() * node.totalWeight;
        let acc = 0;
        let nextId = null;
        for (const item of node.randomNext) {
            acc += item.weight;
            if (r <= acc) {
                nextId = item.next;
                break;
            }
        }
        
        if (nextId) {
             state.currentNodeId = nextId;
             saveState(ctx.player.userId, state);
             processNode(ctx, msg, state); 
        } else {
             replyToSender(ctx, msg, '(错误: 随机分支计算失败)');
        }
        return; 
    } else if (node.next) {
        output += \`\\n(回复 .\${CMD_NAME} \${SC_NEXT} 继续)\`;
    } else {
        output += '\\n(故事结束)';
        state.isEnded = true;
        saveState(ctx.player.userId, state);
    }

    if (output.trim()) {
        replyToSender(ctx, msg, output);
    }
  }

  ext.cmdMap[CMD_NAME] = cmd;
}

main();
`;

export const generatePlugin = (nodes: Node[], edges: Edge[], settings: ProjectSettings): void => {
  // Transform ReactFlow graph to Story Data
  const storyNodes: Record<string, any> = {};
  let startNodeId = null;

  nodes.forEach(node => {
    if (node.data.isStart) startNodeId = node.id;
    
    const nodeData: any = {
      type: node.type,
      text: node.data.text,
    };

    if (node.data.savePointId) {
        nodeData.savePointId = node.data.savePointId;
    }

    // Compile Visual Actions to Script
    if (node.data.actions) {
        nodeData.script = compileActions(node.data.actions as ActionItem[]);
    } else if (node.data.script) {
        // Fallback for legacy script input
        nodeData.script = node.data.script;
    }

    if (node.type === 'choice') {
      const choices: any[] = [];
      const connectedEdges = edges.filter(e => e.source === node.id);
      
      const nodeChoices = node.data.choices as any[];
      if (nodeChoices) {
        nodeChoices.forEach(c => {
            const edge = connectedEdges.find(e => e.sourceHandle === c.id);
            if (edge) {
                const choiceData: any = {
                    text: c.text,
                    next: edge.target
                };
                if (c.actions && c.actions.length > 0) {
                    choiceData.script = compileActions(c.actions);
                }
                choices.push(choiceData);
            }
        });
      }
      nodeData.choices = choices;
    } else if (node.type === 'condition') {
       // Check if Dice Mode
       if (node.data.conditionMode === 'check') {
           nodeData.type = 'check';
           nodeData.checkTarget = node.data.checkTarget;
           nodeData.checkDice = node.data.checkDice;
           // Rules from settings, but for now we pass simple map
           // Edges for check: success, failure, great_success, great_failure
           const successEdge = edges.find(e => e.source === node.id && e.sourceHandle === 'success');
           const failureEdge = edges.find(e => e.source === node.id && e.sourceHandle === 'failure');
           const greatSuccessEdge = edges.find(e => e.source === node.id && e.sourceHandle === 'great_success');
           const greatFailureEdge = edges.find(e => e.source === node.id && e.sourceHandle === 'great_failure');
           
           nodeData.nextSuccess = successEdge?.target;
           nodeData.nextFailure = failureEdge?.target;
           nodeData.nextGreatSuccess = greatSuccessEdge?.target;
           nodeData.nextGreatFailure = greatFailureEdge?.target;
       } else {
           // Compile Visual Conditions
           if (node.data.conditions) {
               nodeData.condition = compileConditions(node.data.conditions as ConditionItem[], (node.data.conditionLogic as string) || 'AND');
           } else {
               nodeData.condition = node.data.condition || 'true';
           }

           const trueEdge = edges.find(e => e.source === node.id && e.sourceHandle === 'true');
           const falseEdge = edges.find(e => e.source === node.id && e.sourceHandle === 'false');
           nodeData.nextTrue = trueEdge?.target;
           nodeData.nextFalse = falseEdge?.target;
       }
    } else {
      // Story node - handle potential random branching
      const outgoingEdges = edges.filter(e => e.source === node.id);
      
      if (outgoingEdges.length > 1) {
          // Multiple edges from a story node -> Random Branch
          nodeData.randomNext = outgoingEdges.map(e => ({
              next: e.target,
              weight: Number(e.data?.weight) || 1
          }));
          nodeData.totalWeight = nodeData.randomNext.reduce((a: number, b: any) => a + b.weight, 0);
      } else if (outgoingEdges.length === 1) {
          // Single edge -> Direct transition
          nodeData.next = outgoingEdges[0].target;
      } else {
          // No outgoing edges -> End of Story
          nodeData.isEnd = true;
      }
    }

    storyNodes[node.id] = nodeData;
  });

  if (!startNodeId && nodes.length > 0) {
    startNodeId = nodes[0].id;
  }

  const storyData = {
    startNodeId,
    nodes: storyNodes
  };

  const headerContent = HEADER_TEMPLATE
    .replace(/__PLUGIN_NAME__/g, settings.pluginName)
    .replace(/__AUTHOR__/g, settings.author)
    .replace(/__VERSION__/g, settings.version)
    .replace(/__DESCRIPTION__/g, settings.description || '')
    .replace(/__HOMEPAGE__/g, settings.homepage || '')
    .replace(/__TIMESTAMP__/g, Math.floor(Date.now() / 1000).toString());

  const sc = settings.subCommands || {};
  const cmdStart = sc.start?.name || 'start';
  const cmdNext = sc.next?.name || 'next';
  const cmdChoose = sc.choose?.name || 'choose';
  const cmdStat = sc.stat?.name || 'stat';
  const cmdLoad = sc.load?.name || 'load';
  const cmdReset = sc.reset?.name || 'reset';
  const cmdClear = sc.clear?.name || 'clear';

  const descStart = sc.start?.help || '开始故事';
  const descNext = sc.next?.help || '继续';
  const descChoose = sc.choose?.help || '选择选项';
  const descStat = sc.stat?.help || '查看状态';
  const descLoad = sc.load?.help || '读取存档';
  const descReset = sc.reset?.help || '重置故事';
  const descClear = sc.clear?.help || '清除数据';

  const defaultHelp = `\${ext.name} Story:\\n.\${CMD_NAME} ${cmdStart} - ${descStart}\\n.\${CMD_NAME} ${cmdNext} - ${descNext}\\n.\${CMD_NAME} ${cmdChoose} <index> - ${descChoose}\\n.\${CMD_NAME} ${cmdStat} - ${descStat}\\n.\${CMD_NAME} ${cmdLoad} <id> - ${descLoad}\\n.\${CMD_NAME} ${cmdReset} - ${descReset}\\n.\${CMD_NAME} ${cmdClear} - ${descClear}`;

  const pluginContent = headerContent + PLUGIN_TEMPLATE_START
    .replace(/__PLUGIN_NAME__/g, settings.pluginName)
    .replace(/__COMMAND_NAME__/g, settings.commandName)
    .replace('__COMMAND_HELP__', defaultHelp)
    .replace(/__SC_START__/g, cmdStart)
    .replace(/__SC_NEXT__/g, cmdNext)
    .replace(/__SC_CHOOSE__/g, cmdChoose)
    .replace(/__SC_STAT__/g, cmdStat)
    .replace(/__SC_LOAD__/g, cmdLoad)
    .replace(/__SC_RESET__/g, cmdReset)
    .replace(/__SC_CLEAR__/g, cmdClear)
    .replace(/__VERSION__/g, settings.version)
    .replace(/__AUTHOR__/g, settings.author)
    .replace('__STORY_DATA_PLACEHOLDER__', JSON.stringify(storyData, null, 2))
    .replace('__CRITICAL_SUCCESS__', (settings.diceRules?.criticalSuccess ?? 5).toString())
    .replace('__CRITICAL_FAILURE__', (settings.diceRules?.criticalFailure ?? 96).toString())
    .replace('__SUCCESS_MODE__', settings.diceRules?.successMode || 'lte')
    .replace('__CRITICAL_SUCCESS_MODE__', settings.diceRules?.criticalSuccessMode || 'lte')
    .replace('__CRITICAL_FAILURE_MODE__', settings.diceRules?.criticalFailureMode || 'gte')
    .replace('__DEFAULT_DICE__', settings.diceRules?.defaultDice || '1d100');

  const filename = settings.filename ? 
    (settings.filename.endsWith('.js') ? settings.filename : `${settings.filename}.js`) : 
    `${settings.pluginName.toLowerCase()}.js`;

  const blob = new Blob([pluginContent], { type: 'text/javascript;charset=utf-8' });
  saveAs(blob, filename);
};
